<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>adapt package &#8212; adapt  documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="adapt.tools package" href="adapt.tools.html" />
    <link rel="prev" title="Welcome to adapt’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="adapt-package">
<h1>adapt package<a class="headerlink" href="#adapt-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="adapt.tools.html">adapt.tools package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="adapt.tools.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="adapt.tools.text.html">adapt.tools.text package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="adapt.tools.text.html#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="adapt.tools.text.html#module-adapt.tools.text.tokenizer">adapt.tools.text.tokenizer module</a></li>
<li class="toctree-l4"><a class="reference internal" href="adapt.tools.text.html#module-adapt.tools.text.trie">adapt.tools.text.trie module</a></li>
<li class="toctree-l4"><a class="reference internal" href="adapt.tools.text.html#module-adapt.tools.text">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="adapt.tools.html#module-adapt.tools">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-adapt.context">
<span id="adapt-context-module"></span><h2>adapt.context module<a class="headerlink" href="#module-adapt.context" title="Permalink to this headline">¶</a></h2>
<p>This is to Manage Context of a Conversation</p>
<p class="rubric">Notes</p>
<p>Comments are subject to evaluation and may not reflect intent.
Comments should be updated as code is clearly understood.</p>
<dl class="class">
<dt id="adapt.context.ContextManager">
<em class="property">class </em><code class="descclassname">adapt.context.</code><code class="descname">ContextManager</code><a class="reference internal" href="_modules/adapt/context.html#ContextManager"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.context.ContextManager" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Use to track context throughout the course of a conversational session.
How to manage a session&#8217;s lifecycle is not captured here.</p>
<dl class="method">
<dt id="adapt.context.ContextManager.get_context">
<code class="descname">get_context</code><span class="sig-paren">(</span><em>max_frames=None</em>, <em>missing_entities=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/context.html#ContextManager.get_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.context.ContextManager.get_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a list of entities from the context.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>max_frames</strong> (<em>int</em>) &#8211; maximum number of frames to look back</li>
<li><strong>missing_entities</strong> (<em>list of str</em>) &#8211; a list or set of tag names, as strings</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list of entities</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.context.ContextManager.inject_context">
<code class="descname">inject_context</code><span class="sig-paren">(</span><em>entity</em>, <em>metadata={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/context.html#ContextManager.inject_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.context.ContextManager.inject_context" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>entity</strong> (<em>object</em>) &#8211; <dl class="docutils">
<dt>format {&#8216;data&#8217;: &#8216;Entity tag as &lt;str&gt;&#8217;,</dt>
<dd><dl class="first last docutils">
<dt>&#8216;key&#8217;: &#8216;entity proper name as &lt;str&gt;&#8217;,</dt>
<dd>&#8216;confidence&#8217;: &lt;float&gt;&#8217;
}</dd>
</dl>
</dd>
</dl>
</li>
<li><strong>metadata</strong> (<em>object</em>) &#8211; dict, arbitrary metadata about the entity being added</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="adapt.context.ContextManagerFrame">
<em class="property">class </em><code class="descclassname">adapt.context.</code><code class="descname">ContextManagerFrame</code><span class="sig-paren">(</span><em>entities=[]</em>, <em>metadata={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/context.html#ContextManagerFrame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.context.ContextManagerFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Manages entities and context for a single frame of conversation.
Provides simple equality querying.</p>
<dl class="attribute">
<dt id="adapt.context.ContextManagerFrame.entities">
<code class="descname">entities</code><a class="headerlink" href="#adapt.context.ContextManagerFrame.entities" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> &#8211; Entities that belong to ContextManagerFrame</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.context.ContextManagerFrame.metadata">
<code class="descname">metadata</code><a class="headerlink" href="#adapt.context.ContextManagerFrame.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p><em>object</em> &#8211; metadata to describe context belonging to ContextManagerFrame</p>
</dd></dl>

<dl class="method">
<dt id="adapt.context.ContextManagerFrame.merge_context">
<code class="descname">merge_context</code><span class="sig-paren">(</span><em>tag</em>, <em>metadata</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/context.html#ContextManagerFrame.merge_context"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.context.ContextManagerFrame.merge_context" title="Permalink to this definition">¶</a></dt>
<dd><p>merge into contextManagerFrame new entity and metadata.</p>
<p>Appends tag as new entity and adds keys in metadata to keys in
self.metadata.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tag</strong> (<em>str</em>) &#8211; entity to be added to self.entities</li>
<li><strong>metadata</strong> (<em>object</em>) &#8211; metadata containes keys to be added to self.metadata</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.context.ContextManagerFrame.metadata_matches">
<code class="descname">metadata_matches</code><span class="sig-paren">(</span><em>query={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/context.html#ContextManagerFrame.metadata_matches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.context.ContextManagerFrame.metadata_matches" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns key matches to metadata</p>
<p>This will check every key in query for a matching key in metadata
returning true if every key is in metadata.  query without keys
return false.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>query</strong> (<em>object</em>) &#8211; metadata for matching</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>True: when key count in query is &gt; 0 and all keys in query in</dt>
<dd>self.metadata</dd>
<dt>False: if key count in query is &lt;= 0 or any key in query not</dt>
<dd>found in self.metadata</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-adapt.engine">
<span id="adapt-engine-module"></span><h2>adapt.engine module<a class="headerlink" href="#module-adapt.engine" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="adapt.engine.DomainIntentDeterminationEngine">
<em class="property">class </em><code class="descclassname">adapt.engine.</code><code class="descname">DomainIntentDeterminationEngine</code><a class="reference internal" href="_modules/adapt/engine.html#DomainIntentDeterminationEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>DomainIntentDeterminationEngine.</p>
<p>The DomainIntentDeterminationEngine is a greedy and naive implementation of intent
determination. Given an utterance, it uses the Adapt parsing tools to come up with a
sorted collection of tagged parses. A valid parse result contains no overlapping
tagged entities in a single domain, and it&#8217;s confidence is the sum of the tagged
entity confidences, which are weighted based on the percentage of the utterance
(per character) that the entity match represents.</p>
<p>This system makes heavy use of generators to enable greedy algorithms to short circuit
large portions of computation.</p>
<dl class="method">
<dt id="adapt.engine.DomainIntentDeterminationEngine.determine_intent">
<code class="descname">determine_intent</code><span class="sig-paren">(</span><em>utterance</em>, <em>num_results=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#DomainIntentDeterminationEngine.determine_intent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.determine_intent" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an utterance, provide a valid intent.</p>
<p>utterance(str): an ascii or unicode string representing natural language speech
num_results(int): a maximum number of results to be returned.</p>
<p>Returns: A generator the yields dictionaries.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.engine.DomainIntentDeterminationEngine.intent_parsers">
<code class="descname">intent_parsers</code><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.intent_parsers" title="Permalink to this definition">¶</a></dt>
<dd><p>A property to link into IntentEngine&#8217;s intent_parsers.</p>
<dl class="docutils">
<dt>Warning: this is only for backwards compatiblility and should not be used if you</dt>
<dd>intend on using domains.</dd>
</dl>
<p>Returns: the domains intent_parsers from its IntentEngine</p>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.DomainIntentDeterminationEngine.register_domain">
<code class="descname">register_domain</code><span class="sig-paren">(</span><em>domain=0</em>, <em>tokenizer=None</em>, <em>trie=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#DomainIntentDeterminationEngine.register_domain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.register_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a domain with the intent engine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tokenizer</strong> (<a class="reference internal" href="adapt.tools.text.html#module-adapt.tools.text.tokenizer" title="adapt.tools.text.tokenizer"><em>tokenizer</em></a>) &#8211; The tokenizer you wish to use.</li>
<li><strong>trie</strong> (<a class="reference internal" href="adapt.tools.text.html#adapt.tools.text.trie.Trie" title="adapt.tools.text.trie.Trie"><em>Trie</em></a>) &#8211; the Trie() you wish to use.</li>
<li><strong>domain</strong> (<em>str</em>) &#8211; a string representing the domain you wish to add</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.DomainIntentDeterminationEngine.register_entity">
<code class="descname">register_entity</code><span class="sig-paren">(</span><em>entity_value</em>, <em>entity_type</em>, <em>alias_of=None</em>, <em>domain=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#DomainIntentDeterminationEngine.register_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.register_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an entity to be tagged in potential parse results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>entity_value</strong> (<em>str</em>) &#8211; the value/proper name of an entity instance
(Ex: &#8220;The Big Bang Theory&#8221;)</li>
<li><strong>entity_type</strong> (<em>str</em>) &#8211; the type/tag of an entity instance (Ex: &#8220;Television Show&#8221;)</li>
<li><strong>domain</strong> (<em>str</em>) &#8211; a string representing the domain you wish to add the entity to</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.DomainIntentDeterminationEngine.register_intent_parser">
<code class="descname">register_intent_parser</code><span class="sig-paren">(</span><em>intent_parser</em>, <em>domain=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#DomainIntentDeterminationEngine.register_intent_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.register_intent_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Register a intent parser with a domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>intent_parser</strong> (<a class="reference internal" href="#module-adapt.intent" title="adapt.intent"><em>intent</em></a>) &#8211; The intent parser you wish to register.</li>
<li><strong>domain</strong> (<em>str</em>) &#8211; a string representing the domain you wish register the intent
parser to.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.DomainIntentDeterminationEngine.register_regex_entity">
<code class="descname">register_regex_entity</code><span class="sig-paren">(</span><em>regex_str</em>, <em>domain=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#DomainIntentDeterminationEngine.register_regex_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.register_regex_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>A regular expression making use of python named group expressions.</p>
<p>Example: (?P&lt;Artist&gt;.*)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>regex_str</strong> (<em>str</em>) &#8211; a string representing a regular expression as defined above</li>
<li><strong>domain</strong> (<em>str</em>) &#8211; a string representing the domain you wish to add the entity to</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="adapt.engine.DomainIntentDeterminationEngine.regular_expressions_entities">
<code class="descname">regular_expressions_entities</code><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.regular_expressions_entities" title="Permalink to this definition">¶</a></dt>
<dd><p>A property to link into IntentEngine&#8217;s regular_expressions_entities.</p>
<dl class="docutils">
<dt>Warning: this is only for backwards compatiblility and should not be used if you</dt>
<dd>intend on using domains.</dd>
</dl>
<p>Returns: the domains regular_expression_entities from its IntentEngine</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.engine.DomainIntentDeterminationEngine.tagger">
<code class="descname">tagger</code><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.tagger" title="Permalink to this definition">¶</a></dt>
<dd><p>A property to link into IntentEngine&#8217;s intent_parsers.</p>
<p>Warning: this is only for backwards compatiblility and should not be used if you
intend on using domains.</p>
<p>Return: the domains intent_parsers from its IntentEngine</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.engine.DomainIntentDeterminationEngine.tokenizer">
<code class="descname">tokenizer</code><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.tokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>A property to link into IntentEngine&#8217;s tokenizer.</p>
<dl class="docutils">
<dt>Warning: this is only for backwards compatiblility and should not be used if you</dt>
<dd>intend on using domains.</dd>
</dl>
<p>Return: the domains tokenizer from its IntentEngine</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.engine.DomainIntentDeterminationEngine.trie">
<code class="descname">trie</code><a class="headerlink" href="#adapt.engine.DomainIntentDeterminationEngine.trie" title="Permalink to this definition">¶</a></dt>
<dd><p>A property to link into IntentEngine&#8217;s trie.</p>
<dl class="docutils">
<dt>Warning: this is only for backwards compatiblility and should not be used if you</dt>
<dd>intend on using domains.</dd>
</dl>
<p>Return: the domains trie from its IntentEngine</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="adapt.engine.IntentDeterminationEngine">
<em class="property">class </em><code class="descclassname">adapt.engine.</code><code class="descname">IntentDeterminationEngine</code><span class="sig-paren">(</span><em>tokenizer=None</em>, <em>trie=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#IntentDeterminationEngine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.IntentDeterminationEngine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pyee.EventEmitter</span></code></p>
<p>The IntentDeterminationEngine is a greedy and naive implementation of intent determination. Given an utterance,
it uses the Adapt parsing tools to come up with a sorted collection of tagged parses. A valid parse result contains
no overlapping tagged entities, and it&#8217;s confidence is the sum of the tagged entity confidences, which are
weighted based on the percentage of the utterance (per character) that the entity match represents.</p>
<p>This system makes heavy use of generators to enable greedy algorithms to short circuit large portions of
computation.</p>
<dl class="method">
<dt id="adapt.engine.IntentDeterminationEngine.check_intent_entities">
<code class="descname">check_intent_entities</code><span class="sig-paren">(</span><em>intent_parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#IntentDeterminationEngine.check_intent_entities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.IntentDeterminationEngine.check_intent_entities" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to check intents for entities that are not registered yet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>intent_parser</strong> (<a class="reference internal" href="#module-adapt.intent" title="adapt.intent"><em>intent</em></a>) &#8211; This is the intent to check the
Entities for.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Returns a list of entities missing from intent_parser.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It&#8217;s up to the caller to deside how to handle missing entities.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.IntentDeterminationEngine.determine_intent">
<code class="descname">determine_intent</code><span class="sig-paren">(</span><em>utterance</em>, <em>num_results=1</em>, <em>include_tags=False</em>, <em>context_manager=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#IntentDeterminationEngine.determine_intent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.IntentDeterminationEngine.determine_intent" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an utterance, provide a valid intent.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>utterance</strong> (<em>str</em>) &#8211; an ascii or unicode string representing natural language speech</li>
<li><strong>include_tags</strong> (<em>list</em>) &#8211; includes the parsed tags (including position and confidence)
as part of result</li>
<li><strong>context_manager</strong> (<em>list</em>) &#8211; a context manager to provide context to the utterance</li>
<li><strong>num_results</strong> (<em>int</em>) &#8211; a maximum number of results to be returned.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Returns: A generator that yields dictionaries.</p>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.IntentDeterminationEngine.register_entity">
<code class="descname">register_entity</code><span class="sig-paren">(</span><em>entity_value</em>, <em>entity_type</em>, <em>alias_of=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#IntentDeterminationEngine.register_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.IntentDeterminationEngine.register_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Register an entity to be tagged in potential parse results</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>entity_value</strong> (<em>str</em>) &#8211; the value/proper name of an entity instance (Ex: &#8220;The Big Bang Theory&#8221;)</li>
<li><strong>entity_type</strong> (<em>str</em>) &#8211; the type/tag of an entity instance (Ex: &#8220;Television Show&#8221;)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.IntentDeterminationEngine.register_intent_parser">
<code class="descname">register_intent_parser</code><span class="sig-paren">(</span><em>intent_parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#IntentDeterminationEngine.register_intent_parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.IntentDeterminationEngine.register_intent_parser" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;Enforce&#8221; the intent parser interface at registration time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>intent_parser</strong> (<a class="reference internal" href="#module-adapt.intent" title="adapt.intent"><em>intent</em></a>) &#8211; Intent to be registered.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code> &#8211; on invalid intent</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.engine.IntentDeterminationEngine.register_regex_entity">
<code class="descname">register_regex_entity</code><span class="sig-paren">(</span><em>regex_str</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/engine.html#IntentDeterminationEngine.register_regex_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.engine.IntentDeterminationEngine.register_regex_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>A regular expression making use of python named group expressions.</p>
<p>Example: (?P&lt;Artist&gt;.*)</p>
<p>regex_str(str): a string representing a regular expression as defined above</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-adapt.entity_tagger">
<span id="adapt-entity-tagger-module"></span><h2>adapt.entity_tagger module<a class="headerlink" href="#module-adapt.entity_tagger" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="adapt.entity_tagger.EntityTagger">
<em class="property">class </em><code class="descclassname">adapt.entity_tagger.</code><code class="descname">EntityTagger</code><span class="sig-paren">(</span><em>trie</em>, <em>tokenizer</em>, <em>regex_entities=[]</em>, <em>max_tokens=20</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/entity_tagger.html#EntityTagger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.entity_tagger.EntityTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Known Entity Tagger
Given an index of known entities, can efficiently search for those entities within a provided utterance.</p>
<dl class="method">
<dt id="adapt.entity_tagger.EntityTagger.tag">
<code class="descname">tag</code><span class="sig-paren">(</span><em>utterance</em>, <em>context_trie=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/entity_tagger.html#EntityTagger.tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.entity_tagger.EntityTagger.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Tag known entities within the utterance.
:param utterance: a string of natural language text
:type utterance: str
:param context_trie: optional, a trie containing only entities from context</p>
<blockquote>
<div>for this request</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
</tbody>
</table>
<dl class="docutils">
<dt>Returns: dictionary, with the following keys</dt>
<dd>match(str): the proper entity matched
key(str): the string that was matched to the entity
start_token(int): 0-based index of the first token matched
end_token(int): 0-based index of the last token matched
entities(list): a list of entity kinds as strings (Ex: Artist, Location)</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-adapt.expander">
<span id="adapt-expander-module"></span><h2>adapt.expander module<a class="headerlink" href="#module-adapt.expander" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="adapt.expander.BronKerboschExpander">
<em class="property">class </em><code class="descclassname">adapt.expander.</code><code class="descname">BronKerboschExpander</code><span class="sig-paren">(</span><em>tokenizer</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#BronKerboschExpander"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.BronKerboschExpander" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Given a list of tagged entities (from the existing entity tagger implementation or another), expand out
valid parse results.</p>
<p>A parse result is considered valid if it contains no overlapping spans.</p>
<p>Since total confidence of a parse result is based on the sum of confidences of the entities, there is no sense
in yielding any potential parse results that are a subset/sequence of a larger valid parse result. By comparing
this concept to that of maximal cliques (<a class="reference external" href="https://en.wikipedia.org/wiki/Clique_problem">https://en.wikipedia.org/wiki/Clique_problem</a>), we can use well known
solutions to the maximal clique problem like the Bron/Kerbosch algorithm (<a class="reference external" href="https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm">https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm</a>).</p>
<p>By considering tagged entities that do not overlap to be &#8220;neighbors&#8221;, BronKerbosch will yield a set of maximal
cliques that are also valid parse results.</p>
<dl class="method">
<dt id="adapt.expander.BronKerboschExpander.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>tags</em>, <em>clique_scoring_func=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#BronKerboschExpander.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.BronKerboschExpander.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main function to expand tags into cliques</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tags</strong> (<em>list</em>) &#8211; a list of tags to find the cliques.</li>
<li><strong>clique_scoring_func</strong> (<em>func</em>) &#8211; a function that returns a float
value for the clique</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a list of cliques</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="adapt.expander.Lattice">
<em class="property">class </em><code class="descclassname">adapt.expander.</code><code class="descname">Lattice</code><a class="reference internal" href="_modules/adapt/expander.html#Lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.Lattice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This manages a list of items or lists</p>
<dl class="attribute">
<dt id="adapt.expander.Lattice.nodes">
<code class="descname">nodes</code><a class="headerlink" href="#adapt.expander.Lattice.nodes" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> &#8211; is a list of items or lists.
This is used to track items and lists that are a part of the
Lattice</p>
</dd></dl>

<dl class="method">
<dt id="adapt.expander.Lattice.append">
<code class="descname">append</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#Lattice.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.Lattice.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends items or lists to the Lattice</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>item</em><em>,</em><em>list</em>) &#8211; The Item or List to be added to the Lattice</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.expander.Lattice.traverse">
<code class="descname">traverse</code><span class="sig-paren">(</span><em>index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#Lattice.traverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.Lattice.traverse" title="Permalink to this definition">¶</a></dt>
<dd><p>This is used to produce a list of lists where each each item
in that list is a diffrent combination of items from the lists
within with every combination of such values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> (<em>int</em>) &#8211; the index at witch to start the list.
Note this is used only in the function as a processing</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">is every combination.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="adapt.expander.SimpleGraph">
<em class="property">class </em><code class="descclassname">adapt.expander.</code><code class="descname">SimpleGraph</code><a class="reference internal" href="_modules/adapt/expander.html#SimpleGraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.SimpleGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class is to graph connected nodes
.. note:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">hash</span> <span class="ow">is</span> <span class="n">a</span> <span class="nb">type</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">hashable</span> <span class="n">so</span> <span class="n">independant</span> <span class="n">values</span> <span class="ow">and</span> <span class="n">tuples</span>
<span class="n">but</span> <span class="ow">not</span> <span class="n">objects</span><span class="p">,</span> <span class="n">classes</span> <span class="ow">or</span> <span class="n">lists</span><span class="o">.</span>
</pre></div>
</div>
<dl class="method">
<dt id="adapt.expander.SimpleGraph.add_edge">
<code class="descname">add_edge</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#SimpleGraph.add_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.SimpleGraph.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to add edges to the graph. &#8216;a&#8217; and &#8216;b&#8217; are vertexes and
if &#8216;a&#8217; or &#8216;b&#8217; doesn&#8217;t exisit then the vertex is created</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> (<em>hash</em>) &#8211; is one vertex of the edge</li>
<li><strong>b</strong> (<em>hash</em>) &#8211; is another vertext of the edge</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.expander.SimpleGraph.get_neighbors_of">
<code class="descname">get_neighbors_of</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#SimpleGraph.get_neighbors_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.SimpleGraph.get_neighbors_of" title="Permalink to this definition">¶</a></dt>
<dd><p>This will return the neighbors of the vertex</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> (<em>hash</em>) &#8211; is the vertex to get the neighbors for</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>a list of neighbors_of &#8216;a&#8217;</dt>
<dd>Will return an empty set if &#8216;a&#8217; doesn&#8217;t exist or has no
neightbors.</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">[]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.expander.SimpleGraph.vertex_set">
<code class="descname">vertex_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#SimpleGraph.vertex_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.SimpleGraph.vertex_set" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns a list of vertexes included in graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of vertexes include in graph</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">[]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="adapt.expander.bronk">
<code class="descclassname">adapt.expander.</code><code class="descname">bronk</code><span class="sig-paren">(</span><em>r</em>, <em>p</em>, <em>x</em>, <em>graph</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#bronk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.bronk" title="Permalink to this definition">¶</a></dt>
<dd><p>This is used to fine cliques and remove them from graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>graph</strong> (<em>graph</em>) &#8211; this is the graph of verticies to search for
cliques</li>
<li><strong>p</strong> (<em>list</em>) &#8211; this is a list of the verticies to search</li>
<li><strong>r</strong> (<em>list</em>) &#8211; used by bronk for the search</li>
<li><strong>x</strong> (<em>list</em>) &#8211; used by bronk for the search</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last"><em>list</em> &#8211; found clique of the given graph and verticies</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="adapt.expander.get_cliques">
<code class="descclassname">adapt.expander.</code><code class="descname">get_cliques</code><span class="sig-paren">(</span><em>vertices</em>, <em>graph</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#get_cliques"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.get_cliques" title="Permalink to this definition">¶</a></dt>
<dd><p>get cliques</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>verticies</strong> (<em>list</em>) &#8211; list of the verticies to search for cliques</li>
<li><strong>graph</strong> (<em>graph</em>) &#8211; a graph used to find the cliques using verticies</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last"><em>list</em> &#8211; a clique from the graph</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="adapt.expander.graph_key_from_tag">
<code class="descclassname">adapt.expander.</code><code class="descname">graph_key_from_tag</code><span class="sig-paren">(</span><em>tag</em>, <em>entity_index</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/expander.html#graph_key_from_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.expander.graph_key_from_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a key from a tag entity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tag</strong> (<a class="reference internal" href="#adapt.entity_tagger.EntityTagger.tag" title="adapt.entity_tagger.EntityTagger.tag"><em>tag</em></a>) &#8211; this is the tag selected to get the key from</li>
<li><strong>entity_index</strong> (<em>int</em>) &#8211; this is the index of the tagged entity</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">String representing the key for the given tagged entity.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">str</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-adapt.intent">
<span id="adapt-intent-module"></span><h2>adapt.intent module<a class="headerlink" href="#module-adapt.intent" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="adapt.intent.Intent">
<em class="property">class </em><code class="descclassname">adapt.intent.</code><code class="descname">Intent</code><span class="sig-paren">(</span><em>name</em>, <em>requires</em>, <em>at_least_one</em>, <em>optional</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#Intent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.Intent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="adapt.intent.Intent.entities">
<code class="descname">entities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#Intent.entities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.Intent.entities" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to get the Entities the intent is looking for.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>A list of Entities the intent is looking for.  This should</dt>
<dd>never be empty but still could be.</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.intent.Intent.validate">
<code class="descname">validate</code><span class="sig-paren">(</span><em>tags</em>, <em>confidence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#Intent.validate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.Intent.validate" title="Permalink to this definition">¶</a></dt>
<dd><p>Using this method removes tags from the result of validate_with_tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Resuts from validate_with_tags</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#module-adapt.intent" title="adapt.intent">intent</a>(<a class="reference internal" href="#module-adapt.intent" title="adapt.intent">intent</a>)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.intent.Intent.validate_with_tags">
<code class="descname">validate_with_tags</code><span class="sig-paren">(</span><em>tags</em>, <em>confidence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#Intent.validate_with_tags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.Intent.validate_with_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate weather tags has required entites for this intent to fire</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tags</strong> (<em>list</em>) &#8211; Tags and Entities used for validation</li>
<li><strong>confidence</strong> (<em>float</em>) &#8211; <p>?</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>Returns intent and tags used by the intent on</dt>
<dd><p class="first last">falure to meat required entities then returns intent with confidence
of 0.0 and an empty list for tags.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#module-adapt.intent" title="adapt.intent">intent</a>, tags</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="adapt.intent.IntentBuilder">
<em class="property">class </em><code class="descclassname">adapt.intent.</code><code class="descname">IntentBuilder</code><span class="sig-paren">(</span><em>intent_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#IntentBuilder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.IntentBuilder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>IntentBuilder, used to construct intent parsers.</p>
<dl class="attribute">
<dt id="adapt.intent.IntentBuilder.at_least_one">
<code class="descname">at_least_one</code><a class="headerlink" href="#adapt.intent.IntentBuilder.at_least_one" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> &#8211; A list of Entities where one is required.
These are seperated into lists so you can have one of (A or B) and
then require one of (D or F).</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.intent.IntentBuilder.requires">
<code class="descname">requires</code><a class="headerlink" href="#adapt.intent.IntentBuilder.requires" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> &#8211; A list of Required Entities</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.intent.IntentBuilder.optional">
<code class="descname">optional</code><a class="headerlink" href="#adapt.intent.IntentBuilder.optional" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> &#8211; A list of optional Entities</p>
</dd></dl>

<dl class="attribute">
<dt id="adapt.intent.IntentBuilder.name">
<code class="descname">name</code><a class="headerlink" href="#adapt.intent.IntentBuilder.name" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str</em> &#8211; Name of intent</p>
</dd></dl>

<p class="rubric">Notes</p>
<p>This is designed to allow construction of intents in one line.</p>
<p class="rubric">Example</p>
<p>IntentBuilder(&#8220;Intent&#8221;).requires(&#8220;A&#8221;).one_of(&#8220;C&#8221;,&#8221;D&#8221;).optional(&#8220;G&#8221;).build()</p>
<dl class="method">
<dt id="adapt.intent.IntentBuilder.build">
<code class="descname">build</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#IntentBuilder.build"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.IntentBuilder.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an intent from the builder&#8217;s specifications.</p>
<p>Returns: an Intent instance.</p>
</dd></dl>

<dl class="method">
<dt id="adapt.intent.IntentBuilder.one_of">
<code class="descname">one_of</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#IntentBuilder.one_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.IntentBuilder.one_of" title="Permalink to this definition">¶</a></dt>
<dd><p>The intent parser should require one of the provided entity types to validate this clause.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> (<em>args</em>) &#8211; <a href="#id1"><span class="problematic" id="id2">*</span></a>args notation list of entity names</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">to continue modifications.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">self</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.intent.IntentBuilder.optionally">
<code class="descname">optionally</code><span class="sig-paren">(</span><em>entity_type</em>, <em>attribute_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#IntentBuilder.optionally"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.IntentBuilder.optionally" title="Permalink to this definition">¶</a></dt>
<dd><p>Parsed intents from this parser can optionally include an entity of the provided type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entity_type</strong> (<em>str</em>) &#8211; an entity type</li>
<li><strong>attribute_name</strong> (<em>str</em>) &#8211; the name of the attribute on the parsed intent. Defaults to match entity_type.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">to continue modifications.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="adapt.intent.IntentBuilder.require">
<code class="descname">require</code><span class="sig-paren">(</span><em>entity_type</em>, <em>attribute_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#IntentBuilder.require"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.IntentBuilder.require" title="Permalink to this definition">¶</a></dt>
<dd><p>The intent parser should require an entity of the provided type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>entity_type</strong> (<em>str</em>) &#8211; an entity type</li>
<li><strong>attribute_name</strong> (<em>str</em>) &#8211; the name of the attribute on the parsed intent. Defaults to match entity_type.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">self to continue modifications.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">self</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="adapt.intent.choose_1_from_each">
<code class="descclassname">adapt.intent.</code><code class="descname">choose_1_from_each</code><span class="sig-paren">(</span><em>lists</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#choose_1_from_each"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.choose_1_from_each" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of lists and returns a list of lists with one item
from each list.  This new list should be the length of each list multiplied
by the others.  18 for an list with lists of 3, 2 and 3.  Also the lenght
of each sub list should be same as the length of lists passed in.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lists</strong> (<em>list of Lists</em>) &#8211; A list of lists</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>returns a list of lists constructions of one item from each</dt>
<dd>list in lists.</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of lists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="adapt.intent.find_first_tag">
<code class="descclassname">adapt.intent.</code><code class="descname">find_first_tag</code><span class="sig-paren">(</span><em>tags</em>, <em>entity_type</em>, <em>after_index=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#find_first_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.find_first_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches tags for entity type after given index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tags</strong> (<em>list</em>) &#8211; a list of tags with entity types to be compared to entity_type</li>
<li><strong>entity_type</strong> (<em>str</em>) &#8211; This is he entity type to be looking for in tags</li>
<li><strong>after_index</strong> (<em>int</em>) &#8211; the start token must be greater than this.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first"><em>obj</em> &#8211; contains the following fields</p>
<dl class="docutils">
<dt>{</dt>
<dd><p class="first">tag(str): is the tag that matched</p>
<p>v(str): ? the word that matched?</p>
<p class="last">confidence(float): is a measure of accuracy.  1 is full confidence and 0 is none.</p>
</dd>
</dl>
<p class="last">}</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="adapt.intent.find_next_tag">
<code class="descclassname">adapt.intent.</code><code class="descname">find_next_tag</code><span class="sig-paren">(</span><em>tags</em>, <em>end_index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#find_next_tag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.find_next_tag" title="Permalink to this definition">¶</a></dt>
<dd><p>This doesn&#8217;t look like it&#8217;s used anywhere?</p>
</dd></dl>

<dl class="function">
<dt id="adapt.intent.is_entity">
<code class="descclassname">adapt.intent.</code><code class="descname">is_entity</code><span class="sig-paren">(</span><em>tag</em>, <em>entity_name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#is_entity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.is_entity" title="Permalink to this definition">¶</a></dt>
<dd><p>This doesn&#8217;t look like it is used any where?</p>
</dd></dl>

<dl class="function">
<dt id="adapt.intent.resolve_one_of">
<code class="descclassname">adapt.intent.</code><code class="descname">resolve_one_of</code><span class="sig-paren">(</span><em>tags</em>, <em>at_least_one</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/intent.html#resolve_one_of"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.intent.resolve_one_of" title="Permalink to this definition">¶</a></dt>
<dd><p>This searches tags for Entities in at_least_one and returns any match</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tags</strong> (<em>list</em>) &#8211; List of tags with Entities to search for Entities</li>
<li><strong>at_least_one</strong> (<em>list</em>) &#8211; List of Entities to find in tags</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">returns None if no match is found but returns any match as an object</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-adapt.parser">
<span id="adapt-parser-module"></span><h2>adapt.parser module<a class="headerlink" href="#module-adapt.parser" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="adapt.parser.Parser">
<em class="property">class </em><code class="descclassname">adapt.parser.</code><code class="descname">Parser</code><span class="sig-paren">(</span><em>tokenizer</em>, <em>tagger</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/parser.html#Parser"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.parser.Parser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pyee.EventEmitter</span></code></p>
<p>Coordinate a tagger and expander to yield valid parse results.</p>
<dl class="method">
<dt id="adapt.parser.Parser.parse">
<code class="descname">parse</code><span class="sig-paren">(</span><em>utterance</em>, <em>context=None</em>, <em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/adapt/parser.html#Parser.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#adapt.parser.Parser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Used to find tags within utterance with a given confidence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>utterance</strong> (<em>str</em>) &#8211; conversational piece given by the user</li>
<li><strong>context</strong> (<em>list</em>) &#8211; a list of entities</li>
<li><strong>N</strong> (<em>int</em>) &#8211; number of results</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first"><em>obj</em> &#8211; contains the following fields</p>
<dl class="docutils">
<dt>{</dt>
<dd><p class="first">utterance(str): the value passed in</p>
<p>tags(list): a list of tags found in utterance</p>
<p>time(time): duration since call of function</p>
<dl class="last docutils">
<dt>confidence(float):</dt>
<dd><p class="first last">A value indicating how confident of a match to the utterance. This might be used to determine
the most likely intent.</p>
</dd>
</dl>
</dd>
</dl>
<p class="last">}</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-adapt">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-adapt" title="Permalink to this headline">¶</a></h2>
<p>[![Stories in Ready](<a class="reference external" href="https://badge.waffle.io/MycroftAI/adapt.png?label=ready&amp;title=Ready)](https://waffle.io/MycroftAI/adapt">https://badge.waffle.io/MycroftAI/adapt.png?label=ready&amp;title=Ready)](https://waffle.io/MycroftAI/adapt</a>)
Getting Started
===============
To take a dependency on Adapt, it&#8217;s recommended to use virtualenv and pip to install source from github.</p>
<blockquote>
<div>$ virtualenv myvirtualenv
$ . myvirtualenv/bin/activate
$ pip install -e git+https://github.com/mycroftai/adapt#egg=adapt-parser</div></blockquote>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>Executable examples can be found in the [examples folder](<a class="reference external" href="https://github.com/MycroftAI/adapt/tree/master/examples">https://github.com/MycroftAI/adapt/tree/master/examples</a>).</p>
</div>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>The Adapt Intent Parser is a flexible and extensible intent definition and determination framework. It is intended to parse natural language text into a structured intent that can then be invoked programatically.</p>
</div>
<div class="section" id="intent-modelling">
<h3>Intent Modelling<a class="headerlink" href="#intent-modelling" title="Permalink to this headline">¶</a></h3>
<p>In this context, an Intent is an action the system should perform. In the context of Pandora, we’ll define two actions: List Stations, and Select Station (aka start playback)</p>
<p>With the Adapt intent builder:</p>
<blockquote>
<div><dl class="docutils">
<dt>list_stations_intent = IntentBuilder(&#8216;pandora:list_stations&#8217;)</dt>
<dd>.require(&#8216;Browse Music Command&#8217;).build()</dd>
</dl>
</div></blockquote>
<p>For the above, we are describing a “List Stations” intent, which has a single requirement of a “Browse Music Command” entity.</p>
<blockquote>
<div><dl class="docutils">
<dt>play_music_command = IntentBuilder(&#8216;pandora:select_station&#8217;)</dt>
<dd>.require(&#8216;Listen Command&#8217;).require(&#8216;Pandora Station&#8217;).optionally(&#8216;Music Keyword&#8217;).build()</dd>
</dl>
</div></blockquote>
<p>For the above, we are describing a “Select Station” (aka start playback) intent, which requires a “Listen Command” entity, a “Pandora Station”, and optionally a “Music Keyword” entity.</p>
</div>
<div class="section" id="entities">
<h3>Entities<a class="headerlink" href="#entities" title="Permalink to this headline">¶</a></h3>
<p>Entities are a named value. Examples include:
<cite>Blink 182</cite> is an <cite>Artist</cite>
<cite>The Big Bang Theory</cite> is a <cite>Television Show</cite>
<cite>Play</cite> is a <cite>Listen Command</cite>
<cite>Song(s)</cite> is a <cite>Music Keyword</cite></p>
<p>For my Pandora implementation, there is a static set of vocabulary for the Browse Music Command, Listen Command, and Music Keyword (defined by me, a native english speaker and all-around good guy). Pandora Station entities are populated via a &#8220;List Stations&#8221; API call to Pandora. Here’s what the vocabulary registration looks like.</p>
<blockquote>
<div><dl class="docutils">
<dt>def register_vocab(entity_type, entity_value):</dt>
<dd># a tiny bit of code</dd>
<dt>def register_pandora_vocab(emitter):</dt>
<dd><dl class="first docutils">
<dt>for v in [&#8220;stations&#8221;]:</dt>
<dd>register_vocab(&#8216;Browse Music Command&#8217;, v)</dd>
<dt>for v in [&#8220;play&#8221;, &#8220;listen&#8221;, &#8220;hear&#8221;]:</dt>
<dd>register_vocab(&#8216;Listen Command&#8217;, v)</dd>
<dt>for v in [&#8220;music&#8221;, &#8220;radio&#8221;]:</dt>
<dd>register_vocab(&#8216;Music Keyword&#8217;, v)</dd>
<dt>for v in [&#8220;Pandora&#8221;]:</dt>
<dd>register_vocab(&#8216;Plugin Name&#8217;, v)</dd>
</dl>
<p>station_name_regex = re.compile(r&#8221;(.*) Radio&#8221;)
p = get_pandora()
for station in p.stations:</p>
<blockquote class="last">
<div><p>m = station_name_regex.match(station.get(&#8216;stationName&#8217;))
if not m:</p>
<blockquote>
<div>continue</div></blockquote>
<dl class="docutils">
<dt>for match in m.groups():</dt>
<dd>register_vocab(&#8216;Pandora Station&#8217;, match)</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="learn-more">
<h3>Learn More<a class="headerlink" href="#learn-more" title="Permalink to this headline">¶</a></h3>
<p>Further documentation can be found at <a class="reference external" href="https://adapt.mycroft.ai">https://adapt.mycroft.ai</a></p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">adapt package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-adapt.context">adapt.context module</a></li>
<li><a class="reference internal" href="#module-adapt.engine">adapt.engine module</a></li>
<li><a class="reference internal" href="#module-adapt.entity_tagger">adapt.entity_tagger module</a></li>
<li><a class="reference internal" href="#module-adapt.expander">adapt.expander module</a></li>
<li><a class="reference internal" href="#module-adapt.intent">adapt.intent module</a></li>
<li><a class="reference internal" href="#module-adapt.parser">adapt.parser module</a></li>
<li><a class="reference internal" href="#module-adapt">Module contents</a><ul>
<li><a class="reference internal" href="#examples">Examples</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#intent-modelling">Intent Modelling</a></li>
<li><a class="reference internal" href="#entities">Entities</a></li>
<li><a class="reference internal" href="#learn-more">Learn More</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to adapt&#8217;s documentation!</a></li>
      <li>Next: <a href="adapt.tools.html" title="next chapter">adapt.tools package</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/adapt.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Author.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/adapt.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>